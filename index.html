import random
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
import colorama
from colorama import Fore, Back, Style
from typing import List, Dict, Any, Tuple
import emoji

class Meeting:
    def __init__(self, title: str, date: datetime, duration: int, 
                 participants: int, priority: int):
        self.title = title
        self.date = date
        self.duration = duration
        self.participants = participants
        self.priority = priority
        self.score = 0.0

class MeetingAnalyzer:
    def __init__(self):
        colorama.init()
        self.meetings_database: List[Dict[str, Any]] = []
        self.meeting_patterns = {
            "Daily Standup": {
                "frequency": "daily",
                "typical_time": "morning",
                "duration": 15,
                "participants": (4, 12),
                "priority": 8,
                "emoji": "‚≠ê"
            },
            "Sprint Planning": {
                "frequency": "bi-weekly",
                "typical_time": "morning",
                "duration": 120,
                "participants": (5, 15),
                "priority": 9,
                "emoji": "üìÖ"
            },
            "Client Meeting": {
                "frequency": "weekly",
                "typical_time": "afternoon",
                "duration": 60,
                "participants": (2, 6),
                "priority": 10,
                "emoji": "ü§ù"
            },
            "Team Building": {
                "frequency": "monthly",
                "typical_time": "afternoon",
                "duration": 180,
                "participants": (8, 30),
                "priority": 6,
                "emoji": "üéÆ"
            },
            "Code Review": {
                "frequency": "weekly",
                "typical_time": "afternoon",
                "duration": 45,
                "participants": (2, 5),
                "priority": 7,
                "emoji": "üíª"
            },
            "Architecture Discussion": {
                "frequency": "monthly",
                "typical_time": "morning",
                "duration": 90,
                "participants": (4, 8),
                "priority": 8,
                "emoji": "üèóÔ∏è"
            },
            "Product Demo": {
                "frequency": "bi-weekly",
                "typical_time": "afternoon",
                "duration": 60,
                "participants": (5, 20),
                "priority": 9,
                "emoji": "üé•"
            },
            "Training Session": {
                "frequency": "monthly",
                "typical_time": "morning",
                "duration": 120,
                "participants": (10, 40),
                "priority": 7,
                "emoji": "üìö"
            },
            "Strategy Meeting": {
                "frequency": "quarterly",
                "typical_time": "morning",
                "duration": 180,
                "participants": (5, 12),
                "priority": 10,
                "emoji": "üéØ"
            },
            "Innovation Workshop": {
                "frequency": "monthly",
                "typical_time": "afternoon",
                "duration": 150,
                "participants": (8, 20),
                "priority": 8,
                "emoji": "üí°"
            }
        }

    def generate_meetings(self, start_date: datetime, 
                         days_ahead: int) -> List[Meeting]:
        meetings = []
        current_date = start_date
        end_date = start_date + timedelta(days=days_ahead)

        while current_date <= end_date:
            for meeting_type, pattern in self.meeting_patterns.items():
                if self._should_schedule_meeting(pattern["frequency"], current_date):
                    meeting_time = self._get_meeting_time(pattern["typical_time"])
                    meeting_date = datetime.combine(current_date.date(), meeting_time)
                    
                    participants = random.randint(*pattern["participants"])
                    
                    meeting = Meeting(
                        title=f"{pattern['emoji']} {meeting_type}",
                        date=meeting_date,
                        duration=pattern["duration"],
                        participants=participants,
                        priority=pattern["priority"]
                    )
                    meetings.append(meeting)
            
            current_date += timedelta(days=1)
        
        return sorted(meetings, key=lambda x: x.date)

    def analyze_meetings(self, meetings: List[Meeting]) -> List[Tuple[str, float]]:
        meeting_scores = {}
        
        for meeting in meetings:
            score = self._calculate_meeting_score(meeting)
            meeting_type = meeting.title.split(" ", 1)[1]  # Remove emoji
            
            if meeting_type not in meeting_scores:
                meeting_scores[meeting_type] = []
            meeting_scores[meeting_type].append(score)

        # Calculate average scores
        avg_scores = {
            m_type: np.mean(scores) 
            for m_type, scores in meeting_scores.items()
        }

        # Sort by score and get top 7
        return sorted(avg_scores.items(), 
                     key=lambda x: x[1], 
                     reverse=True)[:7]

    def _calculate_meeting_score(self, meeting: Meeting) -> float:
        # Base score from priority
        score = meeting.priority * 10

        # Adjust for duration
        if meeting.duration <= 30:
            score *= 1.2
        elif meeting.duration >= 180:
            score *= 0.8

        # Adjust for participants
        if 5 <= meeting.participants <= 15:
            score *= 1.1
        elif meeting.participants > 25:
            score *= 0.9

        # Time of day factor
        hour = meeting.date.hour
        if 9 <= hour <= 11 or 14 <= hour <= 16:
            score *= 1.1
        elif hour < 8 or hour > 17:
            score *= 0.8

        return score

    def _should_schedule_meeting(self, frequency: str, date: datetime) -> bool:
        if frequency == "daily":
            return True
        elif frequency == "weekly":
            return date.weekday() == 0
        elif frequency == "bi-weekly":
            return date.weekday() == 0 and date.isocalendar()[1] % 2 == 0
        elif frequency == "monthly":
            return date.day == 1
        elif frequency == "quarterly":
            return date.day == 1 and date.month in [1, 4, 7, 10]
        return False

    def _get_meeting_time(self, typical_time: str) -> datetime.time:
        if typical_time == "morning":
            hour = random.randint(9, 11)
        else:  # afternoon
            hour = random.randint(14, 16)
        minute = random.choice([0, 15, 30, 45])
        return datetime.time(hour, minute)

class ModernInterface:
    def __init__(self):
        self.colors = {
            "header": Fore.CYAN,
            "normal": Fore.WHITE,
            "highlight": Fore.YELLOW,
            "success": Fore.GREEN,
            "warning": Fore.RED,
            "reset": Style.RESET_ALL
        }

    def display_meetings(self, meetings: List[Meeting]):
        print(f"\n{self.colors['header']}üìÖ Upcoming Meetings Schedule"
              f"{self.colors['reset']}")
        print("=" * 60)

        current_date = None
        for meeting in meetings:
            meeting_date = meeting.date.date()
            
            if current_date != meeting_date:
                current_date = meeting_date
                print(f"\n{self.colors['highlight']}"
                      f"{meeting_date.strftime('%A, %B %d, %Y')}"
                      f"{self.colors['reset']}")
                print("-" * 40)

            print(f"{self.colors['normal']}"
                  f"{meeting.date.strftime('%H:%M')} - "
                  f"{meeting.title}")
            print(f"   Duration: {meeting.duration} min | "
                  f"Participants: {meeting.participants}"
                  f"{self.colors['reset']}")

    def display_analysis(self, analysis_results: List[Tuple[str, float]]):
        print(f"\n{self.colors['header']}üìä Meeting Type Analysis"
              f"{self.colors['reset']}")
        print("=" * 60)

        for i, (meeting_type, score) in enumerate(analysis_results, 1):
            score_color = self._get_score_color(score)
            print(f"{score_color}{i}. {meeting_type}")
            print(f"   Score: {score:.2f}/100{self.colors['reset']}")
            print(f"   {self._get_score_feedback(score)}")

    def _get_score_color(self, score: float) -> str:
        if score >= 80:
            return self.colors["success"]
        elif score >= 60:
            return self.colors["highlight"]
        return self.colors["warning"]

    def _get_score_feedback(self, score: float) -> str:
        if score >= 80:
            return "üåü Highly Effective"
        elif score >= 60:
            return "‚úÖ Meeting Expectations"
        return "‚ö†Ô∏è Needs Optimization"

def main():
    analyzer = MeetingAnalyzer()
    interface = ModernInterface()

    # Generate meetings for the next 14 days
    start_date = datetime.now()
    meetings = analyzer.generate_meetings(start_date, 14)
    
    # Display meetings schedule
    interface.display_meetings(meetings)
    
    # Analyze and display results
    analysis_results = analyzer.analyze_meetings(meetings)
    interface.display_analysis(analysis_results)

if __name__ == "__main__":
    main()
