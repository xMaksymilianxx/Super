import requests
from datetime import datetime, timedelta
import numpy as np
from typing import List, Dict, Any, Tuple
import pandas as pd
from dataclasses import dataclass
import json
from rich.console import Console
from rich.table import Table
from rich import print as rprint
import aiohttp
import asyncio
from statistics import mean, stdev

class OddsAnalyzer:
    def __init__(self, api_key: str = "631900acd2063f2fa684e2257dfa5588"):
        self.api_key = api_key
        self.base_url = "https://api.the-odds-api.com/v4/sports"
        self.bookmakers = [
            "betclic", "bet365", "unibet", "williamhill", 
            "pinnacle", "marathonbet", "bwin"
        ]

    async def fetch_odds(self, sport: str = "soccer") -> Dict[str, Any]:
        """Pobieranie kurs√≥w z r√≥≈ºnych bukmacher√≥w"""
        async with aiohttp.ClientSession() as session:
            url = f"{self.base_url}/{sport}/odds"
            params = {
                "apiKey": self.api_key,
                "regions": "eu",
                "markets": "h2h,totals,spreads",
                "oddsFormat": "decimal",
                "bookmakers": ",".join(self.bookmakers)
            }
            async with session.get(url, params=params) as response:
                return await response.json()

    def analyze_value_bets(self, odds_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analiza value bet√≥w i pu≈Çapek bukmacherskich"""
        value_bets = []
        
        for match in odds_data:
            bookmaker_odds = self._extract_bookmaker_odds(match)
            if not bookmaker_odds:
                continue

            analysis = {
                'match_id': match['id'],
                'home_team': match['home_team'],
                'away_team': match['away_team'],
                'start_time': match['commence_time'],
                'value_opportunities': [],
                'trap_indicators': [],
                'market_analysis': {}
            }

            # Analiza ka≈ºdego rynku
            for market in ['h2h', 'totals', 'spreads']:
                market_analysis = self._analyze_market(bookmaker_odds, market)
                if market_analysis:
                    analysis['market_analysis'][market] = market_analysis

            # Wykrywanie value bet√≥w
            value_opportunities = self._find_value_bets(analysis['market_analysis'])
            if value_opportunities:
                analysis['value_opportunities'] = value_opportunities

            # Wykrywanie pu≈Çapek bukmacherskich
            trap_indicators = self._detect_trap_bets(analysis['market_analysis'])
            if trap_indicators:
                analysis['trap_indicators'] = trap_indicators

            if analysis['value_opportunities'] or analysis['trap_indicators']:
                value_bets.append(analysis)

        return value_bets

    def _extract_bookmaker_odds(self, match: Dict[str, Any]) -> Dict[str, Dict[str, float]]:
        """Ekstrakcja kurs√≥w od r√≥≈ºnych bukmacher√≥w"""
        bookmaker_odds = {}
        for bookmaker in match.get('bookmakers', []):
            if bookmaker['key'] in self.bookmakers:
                markets = {}
                for market in bookmaker.get('markets', []):
                    markets[market['key']] = {
                        outcome['name']: outcome['price']
                        for outcome in market['outcomes']
                    }
                bookmaker_odds[bookmaker['key']] = markets
        return bookmaker_odds

    def _analyze_market(self, bookmaker_odds: Dict[str, Dict[str, float]], 
                       market_type: str) -> Dict[str, Any]:
        """Szczeg√≥≈Çowa analiza konkretnego rynku"""
        market_data = {}
        odds_collection = []

        for bookie, markets in bookmaker_odds.items():
            if market_type in markets:
                market_data[bookie] = markets[market_type]
                odds_collection.extend(markets[market_type].values())

        if not odds_collection:
            return None

        return {
            'mean_odds': mean(odds_collection),
            'std_dev': stdev(odds_collection) if len(odds_collection) > 1 else 0,
            'margin': self._calculate_margin(market_data),
            'outliers': self._detect_outliers(odds_collection),
            'consensus_probability': self._calculate_consensus(market_data)
        }

    def _calculate_margin(self, market_data: Dict[str, Dict[str, float]]) -> float:
        """Obliczanie mar≈ºy bukmacherskiej"""
        margins = []
        for bookie_odds in market_data.values():
            implied_probs = [1/odd for odd in bookie_odds.values()]
            margins.append(sum(implied_probs) - 1)
        return mean(margins) if margins else 0

    def _detect_outliers(self, odds: List[float]) -> List[float]:
        """Wykrywanie odstajƒÖcych kurs√≥w"""
        if len(odds) < 2:
            return []
        
        mean_odd = mean(odds)
        std_dev = stdev(odds)
        return [odd for odd in odds if abs(odd - mean_odd) > 2 * std_dev]

    def _find_value_bets(self, market_analysis: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Identyfikacja value bet√≥w"""
        value_bets = []
        
        for market, analysis in market_analysis.items():
            if analysis['std_dev'] > 0.1:  # ZnaczƒÖca r√≥≈ºnica w kursach
                consensus_prob = analysis['consensus_probability']
                market_odds = 1 / consensus_prob if consensus_prob > 0 else 0
                
                if market_odds > analysis['mean_odds'] * 1.05:  # 5% value
                    value_bets.append({
                        'market': market,
                        'expected_value': market_odds / analysis['mean_odds'] - 1,
                        'confidence': self._calculate_confidence(analysis)
                    })
        
        return value_bets

    def _detect_trap_bets(self, market_analysis: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Wykrywanie potencjalnych pu≈Çapek bukmacherskich"""
        traps = []
        
        for market, analysis in market_analysis.items():
            # Podejrzanie wysokie kursy
            if analysis['outliers']:
                traps.append({
                    'market': market,
                    'type': 'suspicious_odds',
                    'severity': 'high' if analysis['std_dev'] > 0.2 else 'medium'
                })
            
            # Podejrzanie niska mar≈ºa
            if analysis['margin'] < 0.02:  # Mar≈ºa poni≈ºej 2%
                traps.append({
                    'market': market,
                    'type': 'suspicious_margin',
                    'severity': 'high'
                })
        
        return traps

    def _calculate_confidence(self, analysis: Dict[str, Any]) -> float:
        """Obliczanie poziomu pewno≈õci dla danej analizy"""
        confidence = 1.0
        
        # Zmniejsz pewno≈õƒá przy wysokiej odchy≈Çce standardowej
        confidence *= (1 - min(analysis['std_dev'], 0.5))
        
        # Zmniejsz pewno≈õƒá przy wysokiej mar≈ºy
        confidence *= (1 - min(analysis['margin'], 0.3))
        
        # Zmniejsz pewno≈õƒá przy obecno≈õci outlier√≥w
        if analysis['outliers']:
            confidence *= 0.8
            
        return confidence

class MatchAnalyzer(OddsAnalyzer):
    def __init__(self, odds_api_key: str, betclic_api_key: str):
        super().__init__(odds_api_key)
        self.betclic_api_key = betclic_api_key
        self.console = Console()

    async def analyze_matches(self, date: datetime) -> List[Dict[str, Any]]:
        """Kompleksowa analiza mecz√≥w"""
        odds_data = await self.fetch_odds()
        value_bets = self.analyze_value_bets(odds_data)
        
        analyzed_matches = []
        for match in value_bets:
            match_analysis = {
                'basic_info': {
                    'match_id': match['match_id'],
                    'teams': f"{match['home_team']} vs {match['away_team']}",
                    'date': match['start_time']
                },
                'odds_analysis': {
                    'value_opportunities': match['value_opportunities'],
                    'trap_warnings': match['trap_indicators']
                },
                'confidence_score': self._calculate_match_confidence(match)
            }
            analyzed_matches.append(match_analysis)
        
        return sorted(analyzed_matches, 
                     key=lambda x: x['confidence_score'], 
                     reverse=True)

    def display_analysis(self, analyzed_matches: List[Dict[str, Any]]):
        """Wy≈õwietlanie wynik√≥w analizy"""
        table = Table(title="üéØ Analiza Value Bet√≥w i Pu≈Çapek Bukmacherskich")
        
        table.add_column("Mecz", style="cyan")
        table.add_column("Value Bety", style="green")
        table.add_column("Ostrze≈ºenia", style="red")
        table.add_column("Pewno≈õƒá", style="yellow")
        
        for match in analyzed_matches:
            value_bets = "\n".join([
                f"üìà {v['market']}: {v['expected_value']:.1%} EV"
                for v in match['odds_analysis']['value_opportunities']
            ])
            
            warnings = "\n".join([
                f"‚ö†Ô∏è {t['market']}: {t['type']} ({t['severity']})"
                for t in match['odds_analysis']['trap_warnings']
            ])
            
            confidence = match['confidence_score']
            confidence_display = "üåü" * int(confidence * 5)
            
            table.add_row(
                match['basic_info']['teams'],
                value_bets or "Brak",
                warnings or "Brak ostrze≈ºe≈Ñ",
                f"{confidence_display} ({confidence:.1%})"
            )
        
        self.console.print(table)

async def main():
    analyzer = MatchAnalyzer(
        odds_api_key="631900acd2063f2fa684e2257dfa5588",
        betclic_api_key="your_betclic_api_key"
    )
    
    while True:
        rprint("[bold cyan]üéØ System Analizy Value Bet√≥w[/bold cyan]")
        rprint("\n1. üìÖ Analiza na dzi≈õ")
        rprint("2. üìä Analiza na jutro")
        rprint("3. ‚ùå Wyj≈õcie")
        
        choice = input("\nWybierz opcjƒô: ")
        
        if choice == "1":
            analyzed_matches = await analyzer.analyze_matches(datetime.now())
            analyzer.display_analysis(analyzed_matches)
        elif choice == "2":
            analyzed_matches = await analyzer.analyze_matches(
                datetime.now() + timedelta(days=1)
            )
            analyzer.display_analysis(analyzed_matches)
        elif choice == "3":
            break

if __name__ == "__main__":
    asyncio.run(main())
